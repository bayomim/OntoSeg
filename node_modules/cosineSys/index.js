/**
 * @author: Mostafa Bayomi
 * bayomim@tcd.ie
 */

var buildvsm = require('buildVSM');
var sp = require('getShortestPath');
var cp = require('child_process');
var ps = require('ps-node');
var os = require('os');
var fs = require("fs");
var splitTo10 = require('splitto10');
var natural = require('natural');
var cosine = require('cosine')
natural.PorterStemmer.attach();
//var clusterfck = require("clusterfck");
function purifyArray(arr) {
    var pureArr = [];
    var item = JSON.stringify(arr).replace(/]/g, "").replace(/\[/g, "");
    if (item.length > 1) {
        item = item.split(",");
        for (var i = 0; i < item.length; i++) {
            pureArr.push(item[i]);
        }
    }
    else {
        pureArr.push(item);
    }

    return pureArr;
}
exports.run_system = function (filePath, fileName, cb) {

    // read the text file
    var _file = fs.readFileSync(filePath + "/" + fileName + "_h.txt");
    _file = _file.toString();
    var sentences = _file.split("\n");

    // read the output array file
    var fileExper = filePath + "/" + fileName + "_ex.txt";
    var exp = fs.readFileSync(fileExper);
    exp = exp.toString();
    

    var whoWithWho = [];

        // start array by vsm indexes
    var vsm = sentences;
    var initArr = [];
    var wind = 2;
    var vsmlen = vsm.length;
    var itemsNo = Math.ceil(vsmlen / wind);
    console.log("vsmlen%s --  itemsNo:%s", vsmlen, itemsNo);
    for (var i = 0; i < vsmlen;) {
        var windowAr = [];
        for (var j = 0; j < wind; j++) {
            if (i < vsmlen) {
                windowAr.push(i);
            }
            i++;
        }
        initArr.push(windowAr);
    }
    console.log("Init arr:" + initArr)
        ahc(vsm, initArr);



        var forExp = [];
        //   console.log("\n///////////// WHo\n");
        //  console.log(JSON.stringify(whoWithWho));
        for (var i = 0; i < whoWithWho.length; i++) {
            var item = JSON.stringify(whoWithWho[i]).replace(/]/g, "").replace(/\[/g, "");
            if (item.length > 1) {
                item = item.split(",");
                item = item[item.length - 1];
            }
            forExp.push((parseInt(item) + 1));// +1 to match the sentence number as in the true segs
        }

        var file = fs.createWriteStream(fileExper);
        file.on('error', function (err) { console.log("My_Error:" + err); });
        var toWrite = exp;
        toWrite += os.EOL;
        toWrite += "[" + forExp.toString() + "]";
        file.write(toWrite);
        //console.log("toWrite"+toWrite);
        file.end();

        cb();


   




    var totalScore = 0;


    var x;

    function mergeSentences(s, vsm) {
        var newS = "";
        if (Array.isArray(s))// if is array from the second iteration and length if array like [0,1]
        {
           // console.log("Yes is array: " + s);
            if (s.length > 1) {
                //console.log("Yes Len> 1: " + s);
                for (var i = 0; i < s.length; i++) {
                    if (Array.isArray(s[i])) {
                       // console.log("Yes AGAIN is array: " + s[i]);
                        newS = mergeSentences(s[i], vsm);
                    }
                    else {
                        //console.log("NO AGAIN is NOT array: " + s[i]);
                        newS += vsm[s[i]]; // push the classes of these sentences together
                       // console.log("------"+newS)
                    }
                }
            }
            else {// length = 1
                // recursion
                if (Array.isArray(s[0])) {
                    newS = mergeSentences(s[0], vsm);
                }
                else {
                    newS = vsm[s[0]]; // just one sentence
                }
            }
        }
        else { // not array, for the first iteration
            //console.log("! ! ! Not array")
            newS = vsm[s];
        }
        return newS;
    }

    var k = 0;

    var slWindow = 3;
    function ahc(vsm, arr) {
        var vsmScore = [];
        k++;
        if (arr.length > 10) { // 10 segments only
            for (var i = 0; i < arr.length; i++) {
                if (i < arr.length - 1) {
                    var sentence1 = arr[i];
                    var sentence2 = arr[i + 1];
                     //console.log("S1: %s \tS2: %s\n", sentence1, sentence2);
                    sentence1 = mergeSentences(sentence1, vsm);
                    sentence2 = mergeSentences(sentence2, vsm);
                   // console.log("S1: %s \nS2: %s", sentence1, sentence2);
                    // start calculating cosine similarity
                    var ss1 = sentence1.tokenizeAndStem();
                    var ss2 = sentence2.tokenizeAndStem();
                    var cos_score = cosine(ss1, ss2)
                    //console.log("i: %s -- S1: %s", i, cos_score);
                    vsmScore.push(cos_score);
                }
            }
            // till now we have the scores between every two consequent senences
            // console.log("vsmScore: " + vsmScore);
            var threshold = 1;
            var sIndex = 0; // sentences index
            whoWithWho = [];
            var scoreWindowStart = 0;
            var scoreWindowEnd = 0;
            for (var j = 0; ;) {
                scoreWindowEnd = scoreWindowStart + 1;
                var frst = vsmScore[scoreWindowStart]; // score between s1 and s2
                var scnd = vsmScore[scoreWindowEnd]; // score between s2 and s3

                //console.log("\n========== for " + sIndex + " to " + (sIndex+1) );
                if (frst == undefined) {// the last one is left alone 
                    //   console.log("the last one is left alone"+sIndex);
                    whoWithWho.push([arr[sIndex]]);
                    //sIndex += 1;
                    break;
                }
                else if (scnd == undefined) { // the last block
                    //console.log("it is the last block" + sIndex+"::");
                    whoWithWho.push([arr[sIndex], arr[sIndex + 1]]);
                    //sIndex += 1;
                    break;
                }

                else if (frst >= scnd) // score between s1 and s2 >= score bteween s2 and s3
                {
                    //console.log("frst >= scnd");
                    var s1 = sIndex++; // first sentence ++ for the second one
                    var s2 = sIndex; // second sentence
                    whoWithWho.push([arr[s1], arr[s2]]); // s1 and s2 merge together
                    scoreWindowStart += 2;
                    sIndex++;
                }
                else {// score between s1 and s2 <  score bteween s2 and s3
                    // console.log("frst << scnd");
                    scndIsGreater = true;
                    whoWithWho.push([arr[sIndex]]);
                    sIndex++;
                    scoreWindowStart++;
                }
            }

            ahc(vsm, whoWithWho);
        }
        else {
            // check the whoWithWho length, if it is 10, so it is OK, if not, roll back and make it 10
            if (whoWithWho.length == 10) { // perfect
                console.log("Exactly 10");
            }
            else if (whoWithWho.length < 10) {
                console.log("Less than 10, run the secret");
                splitTo10.split(whoWithWho);
            }
            else {
                console.log("------------------Greater than 10, TBC");
            }
            return;
        }
    }

}

