
/**
 * @author: Mostafa Bayomi
 * bayomim@tcd.ie
 * 
 * This module is used for linear segmentation.
 * It is used to produce 10 segemnts out of the final tree produced by OntoSeg (see the paper)
 * The module is used to convert the output of OntoSeg from Hierarchical into Linear.
 * It is used to evaluate the performance of OntoSeg against the SOTA linear segementation approaches.
 * 
 * Now, OntoSeg was commpard against Hierarchical text segmentation approaches. See my new paper for that: http://www.lrec-conf.org/proceedings/lrec2018/pdf/806.pdf
 * 
 */
exports.split = function (whoWithWho) {

    // get the number of segments that we need to lose (i.e. merge them with their neighbours);
    var num_to_lose = 10 - whoWithWho.length;

    var ss_ar_arrays = [];
    for (var i = 0; i < whoWithWho.length; i++) {
        var item = purifyArray(whoWithWho[i]);
        var item_obj = {
            length: item.length, //the array (sentences in one segment) length
            index: i // the array index
        }
        ss_ar_arrays.push(item_obj);
    }
    var whatToLose = getLargest(ss_ar_arrays, num_to_lose);

    var dummy = [];
    for (var i = 0; i < num_to_lose; i++) {
        oneSegment(whatToLose[i], whoWithWho, dummy);
    }
    dummy.sort(compareIndex);
    for (var i = 0; i < dummy.length; i++) {
        updateArray(dummy[i], whoWithWho);
    }
    return whoWithWho;
};


function oneSegment(segment, arr, dumm) {

       var segIndex = segment.index;

        var segValues = arr[segIndex];
        if (segValues.length > 1) {
            var item1 = segValues[0];
            var item2 = segValues[1];
            var obj = {
                mainIndex: segIndex,
                item1: item1,
                item2: item2
            };
            dumm.push(obj)
        }
    }
    function updateArray(obj, arr) {
        var index = obj.mainIndex;
        var item1 = obj.item1;
        var item2 = obj.item2;

        arr.splice(index, 1); // remove the big array from the whoWithWho array
        arr.splice(index, 0, item1);// replace the big array with the first item
        arr.splice(index + 1, 0, item2);// add the second item after the first one
    }

    function compareIndex(a, b) { // descending order
        if (a.mainIndex > b.mainIndex)
            return -1;
        if (a.mainIndex < b.mainIndex)
            return 1;
        return 0;
    }

    function purifyArray(arr) {
        var pureArr = [];
        var item = JSON.stringify(arr).replace(/]/g, "").replace(/\[/g, "");
        if (item.length > 1) {
            item = item.split(",");
            for (var i = 0; i < item.length; i++) {
                pureArr.push(item[i]);
            }
        }
        else {
            pureArr.push(item);
        }

        return pureArr;
    }

    function getLargest(segs, num) {
        segs = sortSegmentsBYLength(segs);
        var indexes = [];
        for (var i = 0; i < num; i++) {
            var x = segs.shift();
            indexes.push(x);
        }
        return indexes;
    }
    function sortSegmentsBYLength(segs) {
        function compare(a, b) { // descending ordr
            if (a.length > b.length)
                return -1;
            if (a.length < b.length)
                return 1;
            return 0;
        }
        segs.sort(compare);
        return segs;
    }
