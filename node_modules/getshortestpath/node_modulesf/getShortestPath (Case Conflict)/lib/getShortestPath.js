var dbp_distance = require('dbp_distance');

var theArr = [];
var shortAR = [];
var cprocess = [];
var parr = [];
exports.getShortestPath = function (n1, n2, callb) {
    //@TODO: check the owl#thing
    var ret;
    if (Array.isArray(n1) && Array.isArray(n2)) {// two arrays of classes
        theArr = [];
        console.log("Two Arrays %s and %s:", n1, n2);
        distArr = [];
        var r = 0;
        
        shortAR = [],
            longAR = [];
        if (n1.length >= n2.length) {
            longAR = n1;
            shortAR = n2;
        }
        else {
            longAR = n2;
            shortAR = n1;
        }
        var carr = [];
        var ar_ar_distance = 0; // @Selim: to summ all distances between two arrays then / by shortAr.length
        for (var u = 0; u < shortAR.length; u++) {
            // @Selim: distance bet one class and array of classes 
            var distan = distFunction(longAR, shortAR[u]);
            ar_ar_distance += distan;
        }
        // @Selim: normalise .. devide by the shortAR length (no. of multiplication operations)
        ret = ar_ar_distance / shortAR.length;
    }
    else if (Array.isArray(n1)) { // array and node
        console.log("array %s and node %s:", n1, n2);
        ret = distFunction(n1, n2);
    }
    else if (Array.isArray(n2)) {// node and array
        console.log("node %s and array %s:", n1, n2);
       ret =  distFunction(n2, n1);
    }
    else { // two nodes
        console.log("node %s and node %s:", n1,n2);
        var dist = dbp_distance.distance(n1,n2);
        ret = dist / 2;// @Selim: normalise .. devide by 2
    }
    console.log("dist:" + ret);
    return ret;
}

function distFunction(arr, nn) { // get the distance between array and one node
   var distancesSum = 0; // @Selim: to summ all distances and divide by arr length (norm)
    for (var i = 0; i < arr.length; i++) {
        var dist = dbp_distance.distance(arr[i], nn);// distance bet 2 nodes
        console.log("Dist bet: %s and %s ia :: %s", arr[i], nn, dist);
        distancesSum += dist;

    }
    distancesSum = distancesSum / arr.length; // @Selim: average (normalise)
    return distancesSum;
}


