sparql = require('sparql');
var _ = require("underscore");
var client = new sparql.Client('http://dbpedia.org/sparql');
var cp = require('child_process');

function getParents(node, cb) {
    /*
    SPARQL:
    select * {
        values (?a) { (dbpedia-owl:Person)}
        { 
            select ?a ?super (count(?mid) as ?aLength)
            {
            ?a rdfs:subClassOf* ?mid .?mid rdfs:subClassOf+ ?super .
            } 
            group by ?super ?a
            order by ?aLength
        }
    }

    */
    var pa = [node];
if (node == "owl#Thing"){
        cb(pa);
}
    else {
        var q = "select * {values (?a) { (dbpedia-owl:" + node + ") } { select ?a ?super (count(?mid) as ?aLength) { ?a rdfs:subClassOf* ?mid .?mid rdfs:subClassOf+ ?super . FILTER ( !strstarts(str(?super), 'http://dbpedia.org/ontology/dul:') ) FILTER ( !strstarts(str(?super), 'http://schema.org/') ) FILTER ( !strstarts(str(?super), 'http://www.ontologydesignpatterns.org/ont/dul/DUL.') )} group by ?super ?a order by ?aLength}}";
        /*
        use filters to remove the none dbpedia ontologies:
        FILTER ( !strstarts(str(?super), "http://dbpedia.org/ontology/dul:") )
        FILTER ( !strstarts(str(?super), "http://schema.org/") )
        FILTER ( !strstarts(str(?super), 'http://www.ontologydesignpatterns.org/ont/dul/DUL.') )
        */
        var parentsArr = [];

        client.query(q, function (err, res) {
            console.log("RESSSS: \n" + res)

            var resources = res.results.bindings;

            var _super = _.pluck(resources, "super");

            parentsArr = _.pluck(_super, "value");

            for (var i = 0; i < parentsArr.length; i++) {
                // remove all none dbpedia
                if (parentsArr[i].indexOf("dbpedia.org") != -1 || parentsArr[i].indexOf("www.w3.org") != -1) {
                    var _class = parentsArr[i].toString().split("/");
                    var className = _class[_class.length - 1];
                    if (className.indexOf("dul") == -1 && className.indexOf("DUL") == -1) { // no multiclasses
                        _class = className;
                        pa.push(_class);
                    }
                }
            }
            cb(pa);

        });
    }
   
}
process.on('message', getDistance);

var getDistance = function (obj) {
    var a = obj.a;
    var b = obj.b;
    
    // a_parents for node a parents including a
    // b_parents for node b parents including b
    //console.log("AA: " + a + " BB: " + b + "\n\n");
    getParents(a, function (a_parents) {
        getParents(b, function (b_parents) {
           // console.log("Parents: \n a:"+a_parents + "\nb:" + b_parents);

            // first check if one of the nodes is a child of the other

            var a_parentof_b = b_parents.indexOf(a);
            var b_parentof_a = a_parents.indexOf(b);
            var minArr, maxArr;
            if (a_parents.length <= b_parents.length) {
                minArr = a_parents;
                maxArr = b_parents
            }
            else {
                minArr = b_parents;
                maxArr = a_parents
            }
            var distance = 0;
            if (a_parentof_b != -1) // node a is a parent (direct or indirect) for node b
            {
                distance = a_parentof_b;
            }
           else if (b_parentof_a != -1) // node a is a child (direct or indirect) of node b
            {
               distance = b_parentof_a;
            }
           else { // no one is parent of the other and we have to get a common parent between them
               var found = false;
               for (var i = 0; i < minArr.length; i++) {
                   for (var j = 0; j < maxArr.length; j++) {
                       if (minArr[i] == maxArr[j]) {
                           console.log("i :" + i + "\nj:" + j + "\n\n");
                           distance = i + j;
                           found = true;
                           break;
                           
                       }
                   }
                   if (found) break;
               }
           }
            if (distance == 0) distance = maxArr.length;

            process.send({ dist: distance});
          
            //console.log(a_parentof_b + ":   -->" + b_parentof_a, " Distance :" + distance);
        }); // end of get b parents
    }); // end of get a parents

}


