/**
 * @author: Mostafa Bayomi
 * bayomim@tcd.ie
 * A module contains helper functions
 */ 

var similarity = require('generalSimilarity');

exports.mergeSentences = function (s, vsm, t) { // the last parameter "t" is just for test
    var newS = [];
    if (Array.isArray(s))// if is array from the second iteration and length if array like [0,1]
    {
        if (s.length > 1) {
            for (var i = 0; i < s.length; i++) {
                if (Array.isArray(s[i])) {
                    newS = exports.mergeSentences(s[i], vsm, t);
                }
                else {
                    newS = newS.concat(vsm[s[i]]); // push the classes of these sentences together
                }
            }
        }
        else {// length = 1
            // recursion
            if (Array.isArray(s[0])) {
                newS = exports.mergeSentences(s[0], vsm, t);
            }
            else {
                newS = vsm[s[0]]; // just one sentence                    newS = vsm[s[0]]; // just one sentence
            }
        }
    }
    else { // not array, for the first iteration
        newS = vsm[s];
    }
    return newS;
};


// this function is to compine every entity in s1 with every entity in s2
exports.buildCombination = function (s1c, s2c) {
    var s1Entities = s1c.length;
    var s2Entities = s2c.length;
    //var len = s1c.length * s2c.length;
    var arr = [];
    if (s1c.length > 0 && s2c.length > 0) {// both sentences have entities
        for (var i = 0; i < s1c.length; i++) {
            var e1 = s1c[i]; // one entity from the first sentence
            for (var j = 0; j < s2c.length; j++) {
                var e2 = s2c[j];// one entity from the second sentence
                {
                    arr.push([e1, e2]);
                }
            }
        }
        var totalNumOfEntities = s1Entities * s2Entities; // the total number of combination operations between the two sentences' entities 
        return { 'arr': arr, 'totalNumOfEntities': totalNumOfEntities };
    }
};

var totalScore = 0;
exports.compare = function (ar, cb) {
    if (ar.length > 0) {
        var frstOne = ar.pop();
        var frst = frstOne[0];
        if (frst.length == 1) frst = frst.toString();
        var scnd = frstOne[1];
        if (scnd.length == 1) scnd = scnd.toString();
        if (frst != "#Not_Found" && scnd != "#Not_Found") {
            // if #Not_Found.. don't calculate the score.
            var score = similarity.sim(frst, scnd);// new similarity method 
            totalScore += score;
        }
        else {
            // do nothing. We dont compare any class with "#Not_Found";
        }
        exports.compare(ar, cb);
    }
    else {
        cb(totalScore);
        totalScore = 0;
        return;
    }
};

exports.initArray = function (wind, vsm) {
    var initArr = [];
    var vsmlen = vsm.length;
    if (wind == 1) { // simple case
        for (var i = 0; i < vsm.length; i++) {
            initArr.push(i);
        }
    }
    else { // window > 1
        for (var i = 0; i < vsmlen;) {
            var windowAr = [];
            for (var j = 0; j < wind; j++) {
                if (i < vsmlen) {
                    windowAr.push(i);
                }
                i++;
            }
            initArr.push(windowAr);
        }
    }
    return initArr;
};
