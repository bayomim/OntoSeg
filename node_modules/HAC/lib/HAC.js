/**
 * @author: Mostafa Bayomi
 * bayomim@tcd.ie
 * 
 * The OntoSeg Algorithm implementation.
 * 
 */
var utils = require('utils');
var splitTo10 = require('splitto10');
var natural = require('natural');
var cosine = require('cosine')
natural.PorterStemmer.attach();
var levelsStr = "";
var pubVSM = [];
var whoWithWho = [];
var ret = null;
var initCounter = 0;
exports.hac = function (vsm, arr, Original_sentences, callb) {
    var vsmScore = [];
    if (arr.length > 1) { 
        for (var i = 0; i < arr.length; i++) {
            if (i < arr.length - 1) {
                var s1index = arr[i];
                var s2index = arr[i + 1];
                // Ontological
                var sentence1 = utils.mergeSentences(s1index, vsm, "onto1"); // the last parameter "onto1" is just for testing
                var sentence2 = utils.mergeSentences(s2index, vsm, "onto2");
                // Cosine
                
                var ss1 = utils.mergeSentences(s1index, Original_sentences, "cos1")
                var ss2 = utils.mergeSentences(s2index, Original_sentences, "cos2");//.tokenizeAndStem();
                if (Array.isArray(ss1)) {
                    ss1 = ss1.join(" ");
                }
                if (Array.isArray(ss2)) {
                    ss2 = ss2.join(" ");
                }
                ss1 = ss1.tokenizeAndStem();
                ss2 = ss2.tokenizeAndStem();
                var cos_score = cosine(ss1, ss2);

                var onto_sim = 0;
                if (sentence1.length != 0 && sentence2.length != 0) {// both of them MUST have entities to be combared
                    var combinationObject = utils.buildCombination(sentence1, sentence2);
                    var combination = combinationObject.arr;
                    var totalNumOfEntities = combinationObject.totalNumOfEntities;
                    if (combination.length > 0) { // after combination, there are still classes to be combared
                        utils.compare(combination, function (score) {
                            onto_sim = score / totalNumOfEntities; // normalisation
                        });
                    }
                    else {
                        onto_sim = 0; // no score between two sentences because one of them (or both) has no entities.
                    }

                }
                else {
                    onto_sim = 0; // no score between two sentences because one of them (or both) has no entities.
                }
                // alpha to specify the weight of each algorithm contribution
                // 0.5 means that both are with the same weight
                // as alpha increases, the weight of cosine effectifness increases and onto decreases
                  var alpha = 0;
                
                  var finalS = onto_sim;
                vsmScore.push(finalS);
            }

        }
        
        // till now we have the scores between every two consequent senences
        var sIndex = 0; // sentences index
        whoWithWho = [];
        var scoreWindowStart = 0;
        var scoreWindowEnd = 0;
        for (var j = 0; ;) {
            scoreWindowEnd = scoreWindowStart + 1;
            var frst = vsmScore[scoreWindowStart]; // score between s1 and s2
            var scnd = vsmScore[scoreWindowEnd]; // score between s2 and s3

            if (frst == undefined) {// the last one is left alone 
                whoWithWho.push([arr[sIndex]]);
                break;
            }
            else if (scnd == undefined) { // the last block
                whoWithWho.push([arr[sIndex], arr[sIndex + 1]]);
                break;
            }

            else if (frst >= scnd) // score between s1 and s2 >= score bteween s2 and s3
            {
                var s1 = sIndex++; // first sentence ++ for the second one
                var s2 = sIndex; // second sentence
                whoWithWho.push([arr[s1], arr[s2]]); // s1 and s2 merge together
                scoreWindowStart += 2;
                sIndex++;
            }
            else {// score between s1 and s2 <  score bteween s2 and s3
                whoWithWho.push([arr[sIndex]]);
                sIndex++;
                scoreWindowStart++;
            }
        }
        // call the function again ... recursion
        exports.hac(vsm, whoWithWho, Original_sentences, callb);
    }
    else {
  
		getTopLevels(whoWithWho);
		callb(fileStr);
	}
}
var nextLevel = [];
var fileStr = "";
function getTopLevels(finalArray){
	
	nextLevel = finalArray[0];
	for (var i = 0; i < 3; i++) {
		nextLevel = getLevelBoundaries(nextLevel,i);	
	}
	console.log("\n----------------\n"+fileStr);
	
}

function getLevelBoundaries(level,levelNumber){
	nextLevel = [];
	var levelStr = "";
	for (var i = 0; i < level.length; i++) {
		var levelItem = level[i];
	//	console.log(levelItem);
		for (var j = 0; j < levelItem.length; j++) {
			nextLevel.push(levelItem[j]);
		}
		levelItem = levelItem.toString().split(",");
		var levelBoundary = levelItem[levelItem.length-1]
		levelStr+= levelBoundary;
		levelStr+=(i < level.length-1)?",":"";
	}
	console.log("\n\n"+levelStr);
	if(levelNumber == 0)
		fileStr =levelStr;
	else
		fileStr =levelStr+"--"+fileStr;
	return nextLevel;
}

