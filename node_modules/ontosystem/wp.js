var buildvsm = require('buildVSM');
var sp = require('getShortestPath');
var cp = require('child_process');
var ps = require('ps-node');
var os = require('os');
var fs = require("fs");
var splitTo10 = require('splitto10');
var natural = require('natural');
var cosine = require('cosine')
natural.PorterStemmer.attach();
var pubVSM = [];
//var clusterfck = require("clusterfck");
// a function to purify array and delete "#Not_Found
Array.prototype.remove = function () {
    var what, a = arguments, L = a.length, ax;
    while (L && this.length) {
        what = a[--L];
        while ((ax = this.indexOf(what)) !== -1) {
            this.splice(ax, 1);
        }
    }
    return this;
};
function purifyArray(arr) {
    var pureArr = [];
        var item = JSON.stringify(arr).replace(/]/g, "").replace(/\[/g, "");
        if (item.length > 1) {
            item = item.split(",");
            for (var i = 0; i < item.length; i++) {
                pureArr.push(item[i]);
            }
        }
        else {
            pureArr.push(item);
        }

    return pureArr;
}
var run_system = function (cb) {

    // read the text file
    var _file = fs.readFileSync("Aircraft.txt.eos.tok");
    _file = _file.toString();
    var sentences = _file.split("\n");
	for(var i =0 ;i<sentences.length;i++){
		// just whith choi's dataset to remove the extra whitespace after each sentence
		sentences[i] = sentences[i].trim();
	}
    // read the output array file
    var fileExper = "0_ex.txt";
    var exp = fs.readFileSync(fileExper);
    exp = exp.toString();
    //console.log("True:" + exp);

    var whoWithWho = [];

    //console.log("S length: " + sentences.length);
    buildvsm.build(sentences, 0, function (vsm) {
        pubVSM = vsm;
        if (sentences.length != vsm.length) console.log("!!!!! ALERT--> VSM != SENTNECES !!!!!");

        // start array by vsm indexes
        // window size
        var initArr = [];
        var wind = 1;
        var vsmlen = vsm.length;
        var itemsNo = Math.ceil(vsmlen / wind);
        console.log("vsmlen%s --  itemsNo:%s", vsmlen, itemsNo);
        if (wind == 1) {
            for (var i = 0; i < vsm.length; i++) {
                initArr.push(i);
            }
        }
        else {
            for (var i = 0; i < vsmlen;) {
                var windowAr = [];
                for (var j = 0; j < wind; j++) {
                    if (i < vsmlen) {
                        windowAr.push(i);
                    }
                    i++;
                }
                initArr.push(windowAr);
            }
        }
        //console.log("Init arr:"+initArr)
        HAC(pubVSM, initArr, sentences);
        var forExp = [];
      //console.log("\n///////////// WHo\n");
      //console.log(JSON.stringify(whoWithWho));
        for (var i = 0; i < whoWithWho.length; i++) {
            var item = JSON.stringify(whoWithWho[i]).replace(/]/g, "").replace(/\[/g, "");
            if (item.length > 1) {
                item = item.split(",");
                item = item[item.length - 1];
            }
            forExp.push((parseInt(item)+1));// +1 to match the sentence number as in the true segs
        }

        var file = fs.createWriteStream(fileExper);
        file.on('error', function (err) { console.log("My_Error:" + err); });
        var toWrite = exp;
        toWrite += os.EOL;
        toWrite += "[" + forExp.toString() + "]";
        file.write(toWrite);
    //console.log("toWrite"+toWrite);
        file.end();

      cb();


    });

	
    function buildCombination(s1, s2) {
        // this function is to compine every entity in s1 with every entity in s2
        // console.log("bc len: %s -- %s", s1.length, s2.length);
        var s1c = s1.slice();
        var s2c = s2.slice();

        //var len = s1c.length * s2c.length;
        var arr = [];
        if (s1c.length > 0 && s2c.length > 0) {// both sentences have entities
            for (var i = 0; i < s1c.length; i++) {
                var e1 = s1c[i]; // one entity from the first sentence

                // we here use slice to copy array by VALUE. before that the remove function affects the original array and 
                // delete the "#Not_found" elements. Althaugh it is not important but we have to check it here.
                if (e1.toString() != "#Not_Found") {
                    for (var j = 0; j < s2c.length; j++) {
                        var e2 = s2c[j];// one entity from the second sentence
                        if (e2.toString() != "#Not_Found") {
                            {
                                arr.push([e1, e2]);
                            }
                        }
                    }

                }
            }
            //console.log("bc len After: %s -- %s", s1l, s2l);
            return arr;
        }
    }
    

    var totalScore = 0;

    function compare(ar, cb) {
        if (ar.length > 0) {
            var frstOne = ar.pop();
            var frst = frstOne[0];
            if (frst.length == 1) frst = frst.toString();
            var scnd = frstOne[1];
            if (scnd.length == 1) scnd = scnd.toString();
            if (frst != "#Not_Found" && scnd != "#Not_Found") {
                // if #Not_Found.. don't calculate the score.
                var score = sp.getShortestPath(frst, scnd); // @Selim: get the distance direct
                totalScore += score;
            }
            else {
                console.log(totalScore);
            }

            compare(ar, cb);
        }
        else {
            cb(totalScore);
            totalScore = 0;
            return;
        }
    }
    /*
    function gsp(arr, arr2) { // get shortest path between two classes or array of classes
        var sum = 0;
        // check if array here
        var ar = arr, ar2 = arr2;
        if (!Array.isArray(arr) && Array.isArray(arr2)) { // "Thing" , ["Person","Agent"]
            ar = arr2;
            ar2 = arr;
        }
        var sc = sp.getShortestPath(ar, ar2);
        var classes = sc.cs.length;
        //console.log("Classes: %s", classes);

        var distanceARr = sc.retArr; // array of distances between nodes .. the longest the farthest

        var total = 0;
        if (Array.isArray(distanceARr)) {
            for (var i = 0; i < distanceARr.length; i++) {
                var num = distanceARr[i];
                if (Array.isArray(distanceARr[i])) {
                    for (var j = 0; j < distanceARr[i].length; j++) {
                        sum += 20 - distanceARr[i][j];
                    }
                }
                else {
                    sum += 20 - distanceARr[i];
                }
            }
        }
        else {
            sum += 20 - distanceARr;
        }
        total = sum / classes;
       // console.log("sum : %s :: Bet : %s and %s is \n Totala %s : ", sum, arr, arr2, total);
        return total;
    }

    */
    /////////////////

    var x;
    function ArrayDepth(arr, jl) {
        x = arr[jl];
        if (Array.isArray(arr[jl])) {
           // console.log(arr[jl] + " is array");
            ArrayDepth(arr[jl], 0);
        }
        else return x;
    }

    function mergeSentences(s, vsm,t) {
        var newS = [];
        if (Array.isArray(s))// if is array from the second iteration and length if array like [0,1]
        {
            if (s.length > 1) {
                for (var i = 0; i < s.length; i++) {
                    if (Array.isArray(s[i])) {
                        newS = mergeSentences(s[i], vsm,t);
                    }
                    else {
                        newS = newS.concat(vsm[s[i]]); // push the classes of these sentences together
                    }
                }
            }
            else {// length = 1
                // recursion
                if (Array.isArray(s[0])) {
                    newS = mergeSentences(s[0], vsm,t);
                }
                else {
                    newS = vsm[s[0]]; // just one sentence
                }
            }
        }
        else { // not array, for the first iteration

            newS = vsm[s];
            //console.log("newS" + newS + "\n-----------------");
        }
        
        return newS;
    }


    function allClasses(sVsm) {

        var ar = [];
        var count = 0;
        for (var i = 0; i < sVsm.length; i++) {
            if (ar.indexOf(sVsm[i]) == -1) {
                ar.push(sVsm[i]);
                count++;
            }
        }
        //    console.log("AR  c:  %s", ar);
        return count;
    }
  
    var k = 0;

    var slWindow = 3;
    var snapshot = [];
    function HAC(vsm, arr, Original_sentences) {
        //console.log(arr);
        // v2: use a sliding window=3 
        var vsmScore = [];
        k++;
        if (arr.length > 1) { // 10 segments only
           // heir(arr);
            console.log("Yes > 10");
            for (var i = 0; i < arr.length; i++) {
                
                if (i < arr.length - 1) {
                    var s1index = arr[i];
                    var s2index = arr[i + 1];
                    // Ontological
                    var sentence1 = mergeSentences(s1index, pubVSM,"onto1");
                    var sentence2 = mergeSentences(s2index, pubVSM, "onto2");
                    // Cosine
                    var ss1 = mergeSentences(s1index, Original_sentences, "cos1")
                    var ss2 = mergeSentences(s2index, Original_sentences, "cos2");//.tokenizeAndStem();
                    if (Array.isArray(ss1)) {
                        ss1 = ss1.join(" ");
                    }
                    if (Array.isArray(ss2)) {
                        ss2 = ss2.join(" ");
                    }
                    ss1 = ss1.tokenizeAndStem();
                    ss2 = ss2.tokenizeAndStem();

                    var cos_score = cosine(ss1, ss2);
                    var onto_score = 0;
                    if (sentence1.length != 0 && sentence2.length != 0) {// both of them MUST have entities to be combared
                        // console.log("OVER len: %s -- %s", sentence1.length, sentence2.length);
                        var combination = buildCombination(sentence1, sentence2);

                        if (combination.length > 0) { // after combination, there are still classes to be combared
                            var entitiesLen = combination.length;
                            compare(combination, function (score) {
                                // @Selim: normalise (entities level x sentences level);
                                onto_score = score / entitiesLen; // normalisation
                                // 11- to get similarity, s alone is the distance
                                // 11 because the maximum distance between 2 classes in dbp graph is 11
                                onto_score = (11 - onto_score) / 11;
                               
                               

                            });
                        }
                        else {
                            onto_score = 0; // no score between two sentences because one of them (or both) has no entities.
                        }
                       
                    }
                    else {
                        onto_score = 0; // no score between two sentences because one of them (or both) has no entities.
                    }
                    // alfa to specify the weight of each algorithm contribution
                    // 0.5 means that both are with the same weight
                    // as alfa increases, as the weight of cosine effectifness increases and onto decreases
                    var alfa = 0.5;
                    //var finalS = cos_score + onto_score;
                    var finalS = alfa * cos_score + (1 - alfa) * onto_score;
                    //console.log("onto_score: %s -- cos_score: %s\nFinal:%s\n------------------", onto_score, cos_score, finalS);
                    vsmScore.push(finalS);
                }
               
            }
            // till now we have the scores between every two consequent senences
            //console.log("vsmScore: " + vsmScore);
          //  conss.log("");
            var threshold = 1;
            var sIndex = 0; // sentences index
            whoWithWho = [];
            var scoreWindowStart = 0;
            var scoreWindowEnd = 0;
            for (var j = 0; ;) {
                scoreWindowEnd = scoreWindowStart + 1;
                var frst = vsmScore[scoreWindowStart]; // score between s1 and s2
                var scnd = vsmScore[scoreWindowEnd]; // score between s2 and s3

                //console.log("\n========== for " + sIndex + " to " + (sIndex+1) );
                if (frst == undefined) {// the last one is left alone 
                 //   console.log("the last one is left alone"+sIndex);
                    whoWithWho.push([arr[sIndex]]);
                    //sIndex += 1;
                    break;
                }
                else if (scnd == undefined) { // the last block
                    //console.log("it is the last block" + sIndex+"::");
                    whoWithWho.push([arr[sIndex], arr[sIndex + 1]]);
                    //sIndex += 1;
                    break;
                }

                else if (frst >= scnd) // score between s1 and s2 >= score bteween s2 and s3
                {
                    //console.log("frst >= scnd");
                    var s1 = sIndex++; // first sentence ++ for the second one
                    var s2 = sIndex; // second sentence
                    whoWithWho.push([arr[s1], arr[s2]]); // s1 and s2 merge together
                    scoreWindowStart += 2;
                    sIndex++;
                }
                else {// score between s1 and s2 <  score bteween s2 and s3
                   // console.log("frst << scnd");
                    scndIsGreater = true;
                    whoWithWho.push([arr[sIndex]]);
                    sIndex++;
                    scoreWindowStart++;
                }
            }

            HAC(vsm, whoWithWho,Original_sentences);
        }
        else {
            // check the whoWithWho length, if it is 10, so it is OK, if not, roll back and make it 10
            if (whoWithWho.length == 10) { // perfect
                console.log("Exactly 10");
            }
            else if (whoWithWho.length < 10) {
                console.log("Less than 10, run the secret");
                console.log(JSON.stringify(whoWithWho.length));
                splitTo10.split(whoWithWho);
            }
            else {
                console.log("------------------Greater than 10, TBC");
            }
            return;
        }
    }

}

run_system(function () {
console.log("Finished")
});

function heir(aray) {
    console.log(aray.length);
    var flag = true;
    for (var i = 0; i < aray.length; i++) {
        var temp = JSON.stringify(aray[i]).replace(/]/g, "").replace(/\[/g, "");;
        var sentences = temp.split(',');
        //if(sentences.length<)
        //console.log("\t"+aray[i].length);
        //console.log(JSON.stringify(sentences)+"--"+sentences.length);
        //console.log("=============");
    }
}